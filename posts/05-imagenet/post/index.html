<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>ImageNet Challenge: The Olympics of Deep Learning | YA&#39;s Almanac</title>
<meta name="keywords" content="">
<meta name="description" content="The ImageNet Large Scale Visual Recognition Challenge (ILSVRC) was an annual competition that took place from 2010 to 2017, attracting teams from around the world to showcase their best-performing image classification models. This challenge became a crucial benchmark in the field, with its winners significantly influencing the landscape of image recognition and deep learning research.
The competition used a subset of the ImageNet dataset, containing 1.3M training examples across 1000 different classes, with 50k validation and 100k test examples.">
<meta name="author" content="">
<link rel="canonical" href="https://yugajmera.github.io/posts/05-imagenet/post/">
<link crossorigin="anonymous" href="https://yugajmera.github.io/assets/css/stylesheet.334cb677465a1d1e9767dd05b097c98de3a5b4085e0d43c708104df17bc49585.css" integrity="sha256-M0y2d0ZaHR6XZ90FsJfJjeOltAheDUPHCBBN8XvElYU=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://yugajmera.github.io/assets/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://yugajmera.github.io/assets/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://yugajmera.github.io/assets/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://yugajmera.github.io/assets/apple-touch-icon.png">
<link rel="mask-icon" href="https://yugajmera.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://yugajmera.github.io/posts/05-imagenet/post/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
  <script>
  MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      displayMath: [['$$','$$'], ['\\[', '\\]']],
      processEscapes: true,
      processEnvironments: true
    },
    options: {
      skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
    }
  };

  window.addEventListener('load', (event) => {
      document.querySelectorAll("mjx-container").forEach(function(x){
        x.parentElement.classList += 'has-jax'})
    });

</script>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script type="text/javascript" id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  
<style>
   mjx-container[display="true"] {
       margin: 1.5em 0 ! important
   }
</style>



<script async src="https://www.googletagmanager.com/gtag/js?id=G-S759YBMKJE"></script>
<script>
var doNotTrack = false;
if (!doNotTrack) {
	window.dataLayer = window.dataLayer || [];
	function gtag(){dataLayer.push(arguments);}
	gtag('js', new Date());
	gtag('config', 'G-S759YBMKJE', { 'anonymize_ip': false });
}
</script>
<meta property="og:title" content="ImageNet Challenge: The Olympics of Deep Learning" />
<meta property="og:description" content="The ImageNet Large Scale Visual Recognition Challenge (ILSVRC) was an annual competition that took place from 2010 to 2017, attracting teams from around the world to showcase their best-performing image classification models. This challenge became a crucial benchmark in the field, with its winners significantly influencing the landscape of image recognition and deep learning research.
The competition used a subset of the ImageNet dataset, containing 1.3M training examples across 1000 different classes, with 50k validation and 100k test examples." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://yugajmera.github.io/posts/05-imagenet/post/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-11-14T00:00:00+00:00" />
<meta property="article:modified_time" content="2022-11-14T00:00:00+00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="ImageNet Challenge: The Olympics of Deep Learning"/>
<meta name="twitter:description" content="The ImageNet Large Scale Visual Recognition Challenge (ILSVRC) was an annual competition that took place from 2010 to 2017, attracting teams from around the world to showcase their best-performing image classification models. This challenge became a crucial benchmark in the field, with its winners significantly influencing the landscape of image recognition and deep learning research.
The competition used a subset of the ImageNet dataset, containing 1.3M training examples across 1000 different classes, with 50k validation and 100k test examples."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://yugajmera.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "ImageNet Challenge: The Olympics of Deep Learning",
      "item": "https://yugajmera.github.io/posts/05-imagenet/post/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "ImageNet Challenge: The Olympics of Deep Learning",
  "name": "ImageNet Challenge: The Olympics of Deep Learning",
  "description": "The ImageNet Large Scale Visual Recognition Challenge (ILSVRC) was an annual competition that took place from 2010 to 2017, attracting teams from around the world to showcase their best-performing image classification models. This challenge became a crucial benchmark in the field, with its winners significantly influencing the landscape of image recognition and deep learning research.\nThe competition used a subset of the ImageNet dataset, containing 1.3M training examples across 1000 different classes, with 50k validation and 100k test examples.",
  "keywords": [
    
  ],
  "articleBody": "The ImageNet Large Scale Visual Recognition Challenge (ILSVRC) was an annual competition that took place from 2010 to 2017, attracting teams from around the world to showcase their best-performing image classification models. This challenge became a crucial benchmark in the field, with its winners significantly influencing the landscape of image recognition and deep learning research.\nThe competition used a subset of the ImageNet dataset, containing 1.3M training examples across 1000 different classes, with 50k validation and 100k test examples. The images were resized to $256 \\times 256$ pixels to standardize input, as they were originally downloaded from the web in various sizes.\nEvaluation was based on two key performance indicators: top-1 and top-5 error rates. The top-5 error rate is the fraction of test images for which the correct label is not among the model’s five most likely predictions. Teams with the lowest top-5 error rate emerged as the winners of this challenge.\nWinners of the challenge each year vs. Top-5 error rate\nEarly years For the first two years, 2010 and 2011, the winning models were not based on neural networks at all. Instead, they relied on multiple layers of hand-designed feature extractors with linear neural networks on top. At the time, training convolutional neural networks (CNNs) on large-scale, high-resolution images was prohibitively expensive due to the computational limitations of available hardware.\nThe breakthrough came in 2012 with the introduction of GPUs, which enabled a highly optimized implementations of 2D convolutions. This, combined with the large-scale ImageNet dataset that provided sufficient labeled examples, made it feasible to train deep CNN models without severe overfitting.\nSeveral factors contributed to the huge leap in 2012:\nData: The availability of the large-scale, well-labeled ImageNet dataset. Computation: Advances in GPUs enabled efficient training of deep networks. Algorithm: The introduction of AlexNet, a deep convolutional network architecture that took full advantage of the above advances, leading to a dramatic improvement in performance. AlexNet (2012) AlexNet [1] was the largest convolutional neural network trained at that time and achieved the best results reported on the ImageNet dataset, outperforming all other competitors by a large margin. This breakthrough made CNNs a mainstream topic in the field of computer vision, and AlexNet became one of the most influential works in the field.\nArchitecture The model has 8 layers: 5 convolutional layers and 3 fully-connected layers.\nActivation function: While Sigmoid and Tanh were common at the time, AlexNet was the first CNN architecture to use ReLU activation. The authors showed empirically that CNNs with ReLU train several times faster than their equivalents using Tanh units.\nNormalization: The authors used “Local Response Normalization” (LRN) after 1st and 2nd convolutional layers, which aided generalization, reducing the top-5 error rate by 1.2%. Although this technique has largely fallen out of use, but it was an early precursor to batch normalization.\nPooling layer: The network includes max-pooling layers with a $3 \\times 3$ kernel and a stride of 2, referred to as “overlapping pooling” due to the overlap of the kernels. The authors observed during training that this approach makes it slightly more difficult for the model to overfit, resulting in 0.3% lower error rate compared to a non-overlapping scheme (kernel size of 2 and stride of 2).\nDropout: The network’s size (60 million parameters) made overfitting a significant problem, even with such a large dataset. To address this, dropout with a probability of $0.5$ was added to the first two fully-connected layers, where the majority of parameters are located. Without dropout, the network required double the number of iterations for convergence.\nModel summary of AlexNet\nData Manipulation Preprocessing: The mean image of the training set (per-pixel mean) is subtracted from each pixel.\nAugmentation: Two data augmentation techniques are used to further reduce overfitting. These augmentations are performed on-the-fly on the CPU, while the GPUs trained the previous batch, making them computationally “free”.\nImage translations and horizontal reflection:\nTraining: Random $224 \\times 224$ patches (and their horizontal reflections) are extracted from $256 \\times 256$ images for training.\nNumber of transformations: $(256 - 224) * (256 - 224) = 1024$ Horizontal reflections: $1024 * 2 = 2048$ Testing: The network makes a prediction by extracting five $224 \\times 224$ patches (four corner patches and the center patch) as well as their horizontal reflections, averaging predictions across all ten patches.\nPCA color augmentation (also called Fancy PCA): This technique alters the intensities of the RGB channels in the training images. It captures an important property of images—that object identity remains invariant to changes in intensity and illumination color.\nTraining Key hyperparameters used for training AlexNet:\nInitialization:\nWeights: Initialized from a zero-mean Gaussian distribution with a standard deviation of $0.01$ for each layer. Bias: Initialized to $1$ for the 2nd, 4th, and 5th convolutional layers, as well as in the fully connected layers. This choice accelerates early learning by providing ReLUs with positive inputs. All other layers have their biases initialized to $0$. Loss Function: Cross-entropy loss.\nOptimizer: Stochastic gradient descent (SGD)\nMomentum $m = 0.9$ L2 weight decay $\\lambda = 5e^{-4}$ Batch size: 128 Learning rate: Initially set to $0.01$ and reduced three times prior to termination by dividing by 10 when the validation error rate stopped improving with the current learning rate.\nNumber of epochs: 90\nTraining time: 5 to 6 days on two GTX 580 3GB GPUs.\nThe image above illustrates a typical AlexNet architecture. The model was spread across two GTX 580 3GB GPUs, as it was too large to fit into the memory of a single GPU. The GPUs communicated only in certain layers to optimize computation. However, with modern hardware, this complexity is unnecessary; today, the entire model can be trained on a single GPU (Google Colab, for instance, offers 12GB/16GB GPUs).\nSubmission: The CNN architecture described above achieved a top-5 error rate of 18.2%. The authors submitted an ensemble of 5 similar CNNs that yielded an error rate of 16.4%, winning the 2012 challenge.\nZFNet (2013) With AlexNet stealing the show in 2012, there was a significant increase in the number of CNN models submitted to ILSVRC 2013. The winner was ZFNet [2], an improved version of AlexNet that tweaked some layer configurations to achieve better performance.\nFirst layer adjustment: Alexnet used a large filter size of $11 \\times 11$ with a stride of 4 in the first layer. While this aggressive downsampling reduced computational cost, it also resulted in the loss of relevant pixel information. To address this, ZFNet used a $7 \\times 7$ sized filter with a stride of 2 in the first layer. To justify these changes, the authors proposed “deconvnet”, a technique to project output feature maps from each convolutional layer back to the input pixel space. This allows us to visualize different types of features learned by each layer, providing insights into the inner workings of CNNs:\nVisualization: Initial layers learn to detect general patterns such as corners, edges, and textures, while deeper layers capture class-specific details like dog faces, bird legs, and other object parts.\nEvolution during training: Lower layers of the model converged within a few epochs, while the upper layers only developed after a considerable number of epochs, demonstrating the need to let the models train until fully converged.\nInvariance: Small transformations strongly affect the first layer, while higher layers show greater stability, with minimal impact from translations and scalings. The network output remains stable under these transformations.\nOcclusion: When an object is occluded, the probability of the correct class drops significantly, indicating that the model relies heavily on local structure within the image rather than broad scene context.\nModel size adjustment: The authors also conducted an ablation study that revealed performance gains from increasing the size of the middle convolutional layers. Consequently, they modified layers 3, 4, and 5 to have 512, 1024, and 512 output channels, respectively. An ensemble of 6 CNNs—five with the modified first layer and one incorporating both modifications—achieved the lowest error rate.\nImageNet 2012 classification error rates\nAlexNet and ZFNet were designed in a somewhat ad-hoc manner, with an arbitrary number of convolution and pooling layers, and the configurations of each layer set by trial and error. This makes scaling them quite challenging.\nVGGNet (2014) In 2014, the second-place winner of the ImageNet challenge was VGGNet [3], developed by the Visual Geometry Group at Oxford. This architecture was one of the first to have a principled design that guided the overall configuration of the network, enabling the creation of deeper networks and achieving significant improvements over previous configurations.\nArchitecture Let’s take a look at a side-by-side comparison of AlexNet, ZFNet, VGG-16, and VGG-19 architectures.\nVGGNet features clean and simple design principles. The configuration for each stage is fixed as follows:\nConvolutional layers: Kernel size of $3 \\times 3$, with a stride of 1 and padding of 1 (same padding).\nWhy? This is the smallest kernel capable of capturing directionality (left/right, up/down, center). This design choice ensures that the network remains compact while allowing for greater depth. Max-pooling layers: Kernel size of $2 \\times 2$, with a stride of 2.\nChannels: Starting from 64, the number of channels doubles after each pooling layer, reaching a maximum of 512.\nWhen the pooling layer downsamples the feature map by half, we double the number of channels to preserve the overall volume, thereby maintaining consistent time complexity (FLOPs) across each layer. Activation: ReLU non-linearities are used thoughout the network.\nNormalization: No normalization is applied, as it does not improve performance and instead increases memory consumption and computation time.\nDropout: Added to the first two fully connected layers, with a dropout ratio of $0.5$.\nWhile AlexNet has 5 convolutional layers, VGGNet comprises 5 stages:\nStage 1: conv-conv-pool\nStage 2: conv-conv-pool\nStage 3: conv-conv-conv-[conv]-pool\nStage 4: conv-conv-conv-[conv]-pool\nStage 5: conv-conv-conv-[conv]-pool\nTwo VGGNet variants were presented: VGG-16 and VGG-19, with 16 and 19 layers, respectively. VGG-19 includes an additional convolutional layer in stages 3, 4, and 5.\nThe convolutional layers are stacked to increase the receptive field. For instance, a stack of two $3 \\times 3$ layers achieves an effective receptive field of $5 \\times 5$, and three layers result in $7 \\times 7$. What do we gain by using three $3 \\times 3$ layers instead of a single $7 \\times 7$ layer?\nMore activations:Three non-linearities instead of one, making the decision function more discriminative.\nFewer parameters: Assuming the input and output have $C$ channels:\nThree $3 \\times 3$ layers: $3(3 * 3 * C^2) = 27C^2$ params. A single $7 \\times 7$ layer: $7 * 7 * C^2 = 49C^2$ params. Data Manipulation Preprocessing: The mean RGB value from the training set (per-channel mean) is subtracted from each pixel.\nAugmentation: Training images are first rescaled to a training scale, $S$. These rescaled images are then randomly cropped to $224 \\times 224$ and undergo random horizontal flipping and random RGB color shifting (similar to AlexNet).\nSingle training scale:\nTraining: Models are trained at two fixed scales, $S = 256$ or $S = 384$. Testing: The output is averaged over three test image versions rescaled at $ \\{ S - 32, S, S + 32 \\} $. Multi-training scale:\nTraining: Each image is rescaled individually by randomly sampling $S$ from the range $[S_{min} =256, S_{max} = 512]$. This approach, called scale jittering, enables the model to recognize objects at different scales. Testing: The output is averaged over three test image versions rescaled at $ \\{ S_{min}, S_{avg}, S_{max} \\} = \\{256, 384, 512 \\} $. This provides three trained versions of the same network: two single-scale models trained at fixed scales and one model trained using multiple scales.\nTraining Training hyperparameters and choices are similar to AlexNet.\nInitialization:\nPre-training: A shallow network is first trained with random initialization (weights from a zero-mean Gaussian distribution with $0.01$ variance and biases set to $0$), and then re-trained with additional convolutional layers. Xavier initialization: After submission, the authors discovered that Xavier initialization enables training without the need for pre-training. Loss Function: Cross-entropy loss.\nOptimizer: Stochastic gradient descent (SGD)\nMomentum $m = 0.9$ L2 weight decay $\\lambda = 5e^{-4}$ Batch size: 256 Learning rate: Initialized at $0.01$, and reduced three times by dividing by 10 when the validation accuracy stopped improving.\nNumber of epochs: 74\nTraining time: 2-3 weeks on four Titan Black 6GB GPUs.\nDespite having more parameters and greater depth than AlexNet, VGGNet required fewer epochs to converge due to (a) implicit regularization imposed by greater depth and and smaller convolutional filter sizes, and (b) pre-initialization of certain layers.\nSubmission: The authors submitted an ensemble of 7 networks—six single-scale models and one multi-scale model—resulting in a top-5 error rate of 7.3%.\nResNet (2015) By 2015, it had become clear that increasing a network’s depth significantly improved its performance. However, deep networks typically face two major challenges:\nOverfitting: Regularization techniques like Batch Normalization (BatchNorm) help mitigate overfitting and enable higher learning rates.\nVanishing/Exploding gradients: Non-saturating activations like ReLU, combined with Kaiming Initialization to preserve signal variance, help address this. BatchNorm further ensures that forward-propagated signals maintain stable, non-zero variances.\nWThe development of BatchNorm and Kaiming Initialization in 2015 set the stage for experimenting with deeper models. However, a “degradation problem” came into light: as network depth increased, accuracy would initially saturate (which might be expected) and then degrade rapidly.\nTraining error (left) and test error (right) on CIFAR-10 with 20-layer and 56-layer networks. The deeper network has higher training and test error.\nThis degradation is not caused by overfitting, as deeper networks exhibit higher training error than their shallower counterparts, as shown in the figure above. The hypothesis suggests that this may be an optimization problem, indicating that deeper models are challenging to optimize, leading to underfiting.\nArchitecture Intuitively, we expect a deeper model to perform at least as well as a shallower model since it could theoretically emulate the shallower network by copying its layers and and setting the extra layers to identity. The fact that deeper models performed worse suggests that the solvers struggle to approximate identity mappings with multiple non-linear layers.\nResidual Block To address this, ResNet [4] introduced a new network design that simplifies learning identity mappings. If we let the stacked non-linear layers fit a mapping $\\text{F(x)}$ for an input $\\text{x}$, we can add a skip connection to recasted the original mapping to $\\text{F(x) + x}$.\nTo the extreme, if an indentity mapping was optimal, the solver would push the residual to zero, i.e. drive the weights of non-linear layers toward zero to approximate the identity mapping.\nWhile it is unlikely that identity mappings are optimal in practice, this reformulation helps precondition the problem, making it easier for the solver to find perturbations relative to an identity mapping rather than learning a new function from scratch.\nThese shortcut connections neither add extra parameters nor increase computational complexity, and they can be trained end-to-end using SGD with backpropagation without modification.\nA residual network, or ResNet, is formed by stacking multiple residual blocks. The image below shows a comparison of VGG-19, 34-layer plain, and residual networks.\nSimilar to VGGNet, ResNet is divided into four stages, each with a different number of residual blocks. The architecture includes:\nAggresive Stem: The input is aggressively downsampled with a $7 \\times 7$ filter and stride 2 (similar to ZFNet) before applying residual blocks.\nResidual block: Each residual block contains two $3 \\times 3$ convolutional layers.\nElement-wise addition is performed on two feature maps, channel by channel.\nSkip connection across two stages (shown by dotted lines): A $1 \\times 1$ convolution is added to the input to match the channel dimension, using a stride of 2 to match the spatial dimension. The output is given by, $$ \\text{H(x) = F(x) + W x} $$ where $\\text{W}$ is the projection shortcut, used solely for changing dimensions; other shortcuts are identity.\nChannels: Starting with 64 channels, the number is doubled after each stage, up to 512.\nStrided convolution: Instead of using pooling layers to halve the feature map after each stage, a stride of 2 is used in the first convolution of the next stage.\nNormalization: Each convolution is followed by a BatchNorm layer and a ReLU activation function.\nGlobal average pooling: Instead of using fully connected layers, the network ends with a global average pooling layer followed by a single linear layer with softmax to generate class scores.\nWhy? Fully connected layers have large number of parameters, increasing memory usage. Average pooling is applied to the last convolutional layer ($512 \\times 7 \\times 7$) using a $7 \\times 7$ kernel to cover the entire spatial structure. The authors presented two variants, ResNet-18 and ResNet-34, which have lower complexity than VGG-19, which has 19.6 GFLOPs.\nAs the 34-layer network performed better than the 18-layer network, it was clear that adding more layers could yield better performance. However, this also increases computational costs.\nBottleneck Residual Block To reduce computation, a bottleneck block is introduced with three convolutions: $1 \\times 1$, $3 \\times 3$ and $1 \\times 1$. The pointwise convolutions are used to reduce and then restore dimensions.\nComparing FLOPs = $(C_{out} \\times H’ \\times W’)* (C_{in} \\times K_w \\times K_h)$,\nBasic residual block: $2 * [(64 \\times 56 \\times 56) * (64 \\times 3 \\times 3)]$ = $0.24$ GFLOPs.\nBottleneck residual block: $2 * [(64 \\times 56 \\times 56) * (256 \\times 1 \\times 1)]$ + $[(64 \\times 56 \\times 56) * (64 \\times 3 \\times 3)]$ = $0.22$ GFLOPs.\nThese additions introduce extra layers and non-linearities with a slight reduction in computational cost, enabling ResNet to add more layers without significantly increasing overall complexity.\nReplacing all basic blocks in ResNet-34 with bottleneck blocks results in the ResNet-50 architecture, a widely-used baseline. The authors further expanded ResNet with 101 and 152-layer variants using different numbers of bottleneck blocks.\nArchitecture of ResNet variants. Downsampling is performed by the first convolution of stages 2, 3, and 4 with a stride of 2. Error rates shown are for single-crop testing, as reported by torchvision.\nData Manipulation Preprocessing: A per-pixel mean is subtracted, as in AlexNet.\nAugmentation: Similar to VGGNet, multi-scale training is applied.\nTraining: Images are randomly rescaled in range $[256, 480]$ for scale augmentation, then randomly cropped to $224 \\times 224$, and subjected to random horizontal flipping and random RGB color shifting.\nTesting: Scores are averaged across multiple scales: $\\{ 224, 256, 384, 480, 640 \\}$.\nTraining Ttraining hyperparameters and choices are as follows.\nInitialization: Kaiming Initialization\nLoss Function: Cross-entropy loss.\nOptimizer: Stochastic gradient descent (SGD)\nMomentum $m = 0.9$ L2 weight decay $\\lambda = 1e^{-4}$ Batch size: 256 Learning rate: Initialized at $0.1$ and divided by 10 when the error plateus.\nNumber of epochs: 120 ($60 \\times 10^{4}$ iterations)\nSubmission: The authors submitted an ensemble of six networks with varying depths, achieving a 3.57% error rate—surpassing human performance and securing the 2015 ImageNet challenge win.\nTransfer Learning Beyond using these CNN models solely for inspiration, transfer learning enables us to apply them directly to many tasks—even with limited training data!\nThe core idea is to take a model pre-trained on ImageNet, remove its last fully-connected layer, and freeze the weights of the remaining layers. With this setup, the pre-trained model becomes an excellent feature extractor, effectively capturing complex patterns from input images.\nSmaller dataset: For smaller datasets, we typically train a new linear layer on top of this feature extractor, tailored to our specific task. This approach has proven effective across various downstream tasks, delivering impressive performance even with minimal data.\nLarger dataset: For larger datasets, you can go further with fine-tuning. Here, we combine the new linear layer with the pre-trained network and jointly train them on the new data. This gradual adjustment allows the network to adapt to the nuances of the new dataset while retaining valuable prior knowledge.\nReferences [1] Alex Krizhevsky, Ilya Sutskever, and Geoffrey Hinton, “ImageNet Classification with Deep Convolutional Neural Networks”, NeurIPS 2012.\n[2] Matthew D. Zeiler and Rob Fergus. “Visualizing and Understanding Convolutional Networks”, ECCV 2014.\n[3] Simonyan and Zissermann, “Very Deep Convolutional Networks for Large-Scale Image Recognition”, ICLR 2015.\n[4] He et al, “Deep Residual Learning for Image Recognition”, CVPR 2016.\n",
  "wordCount" : "3339",
  "inLanguage": "en",
  "datePublished": "2022-11-14T00:00:00Z",
  "dateModified": "2022-11-14T00:00:00Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://yugajmera.github.io/posts/05-imagenet/post/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "YA's Almanac",
    "logo": {
      "@type": "ImageObject",
      "url": "https://yugajmera.github.io/assets/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://yugajmera.github.io/" accesskey="h" title="YA&#39;s Almanac (Alt + H)">YA&#39;s Almanac</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://yugajmera.github.io/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="https://yugajmera.github.io/archives/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="https://yugajmera.github.io/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      ImageNet Challenge: The Olympics of Deep Learning
    </h1>
    <div class="post-meta"><span title='2022-11-14 00:00:00 +0000 UTC'>November 14, 2022</span>&nbsp;·&nbsp;16 min

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#early-years" aria-label="Early years">Early years</a></li>
                <li>
                    <a href="#alexnet-2012" aria-label="AlexNet (2012)">AlexNet (2012)</a><ul>
                        
                <li>
                    <a href="#architecture" aria-label="Architecture">Architecture</a></li>
                <li>
                    <a href="#data-manipulation" aria-label="Data Manipulation">Data Manipulation</a></li>
                <li>
                    <a href="#training" aria-label="Training">Training</a></li></ul>
                </li>
                <li>
                    <a href="#zfnet-2013" aria-label="ZFNet (2013)">ZFNet (2013)</a></li>
                <li>
                    <a href="#vggnet-2014" aria-label="VGGNet (2014)">VGGNet (2014)</a><ul>
                        
                <li>
                    <a href="#architecture-1" aria-label="Architecture">Architecture</a></li>
                <li>
                    <a href="#data-manipulation-1" aria-label="Data Manipulation">Data Manipulation</a></li>
                <li>
                    <a href="#training-1" aria-label="Training">Training</a></li></ul>
                </li>
                <li>
                    <a href="#resnet-2015" aria-label="ResNet (2015)">ResNet (2015)</a><ul>
                        
                <li>
                    <a href="#architecture-2" aria-label="Architecture">Architecture</a><ul>
                        
                <li>
                    <a href="#residual-block" aria-label="Residual Block">Residual Block</a></li>
                <li>
                    <a href="#bottleneck-residual-block" aria-label="Bottleneck Residual Block">Bottleneck Residual Block</a></li></ul>
                </li>
                <li>
                    <a href="#data-manipulation-2" aria-label="Data Manipulation">Data Manipulation</a></li>
                <li>
                    <a href="#training-2" aria-label="Training">Training</a></li></ul>
                </li>
                <li>
                    <a href="#transfer-learning" aria-label="Transfer Learning">Transfer Learning</a></li>
                <li>
                    <a href="#references" aria-label="References">References</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><p>The ImageNet Large Scale Visual Recognition Challenge (ILSVRC) was an annual competition that took place from 2010 to 2017, attracting teams from around the world to showcase their best-performing image classification models. This challenge became a crucial benchmark in the field, with its winners significantly influencing the landscape of image recognition and deep learning research.</p>
<p>The competition used a subset of the ImageNet dataset, containing 1.3M training examples across 1000 different classes, with 50k validation and 100k test examples.  The images were resized to $256 \times 256$ pixels to standardize input, as they were originally downloaded from the web in various sizes.</p>
<p>Evaluation was based on two key performance indicators: top-1 and top-5 error rates. The top-5 error rate is the fraction of test images for which the correct label is not among the model&rsquo;s five most likely predictions. Teams with the lowest top-5 error rate emerged as the winners of this challenge.</p>
<figure class="align-center ">
    <img loading="lazy" src="../timeline.png#center"
         alt="Winners of the challenge each year vs. Top-5 error rate"/> <figcaption>
            <p>Winners of the challenge each year vs. Top-5 error rate</p>
        </figcaption>
</figure>

<h2 id="early-years">Early years<a hidden class="anchor" aria-hidden="true" href="#early-years">#</a></h2>
<p>For the first two years, 2010 and 2011, the winning models were not based on neural networks at all. Instead, they relied on multiple layers of hand-designed feature extractors with linear neural networks on top. At the time, training convolutional neural networks (CNNs) on large-scale, high-resolution images was prohibitively expensive due to the computational limitations of available hardware.</p>
<p>The breakthrough came in 2012 with the introduction of GPUs, which enabled a highly optimized implementations of 2D convolutions. This, combined with the large-scale ImageNet dataset that provided sufficient labeled examples, made it feasible to train deep CNN models without severe overfitting.</p>
<p>Several factors contributed to the huge leap in 2012:</p>
<ul>
<li>Data: The availability of the large-scale, well-labeled ImageNet dataset.</li>
<li>Computation: Advances in GPUs enabled efficient training of deep networks.</li>
<li>Algorithm: The introduction of AlexNet, a deep convolutional network architecture that took full advantage of the above advances, leading to a dramatic improvement in performance.</li>
</ul>
<h2 id="alexnet-2012">AlexNet (2012)<a hidden class="anchor" aria-hidden="true" href="#alexnet-2012">#</a></h2>
<p>AlexNet <a href="#references">[1]</a> was the largest convolutional neural network trained at that time and achieved the best results reported on the ImageNet dataset, outperforming all other competitors by a large margin. This breakthrough made CNNs a mainstream topic in the field of computer vision, and AlexNet became one of the most influential works in the field.</p>
<h3 id="architecture">Architecture<a hidden class="anchor" aria-hidden="true" href="#architecture">#</a></h3>
<p>The model has 8 layers: 5 convolutional layers and 3 fully-connected layers.</p>
<figure class="align-center ">
    <img loading="lazy" src="../alexnet.png#center"/> 
</figure>

<p><strong>Activation function</strong>: While Sigmoid and Tanh were common at the time, AlexNet was the first CNN architecture to use ReLU activation. The authors showed empirically that CNNs with ReLU train several times faster than their equivalents using Tanh units.</p>
<p><strong>Normalization</strong>: The authors used &ldquo;Local Response Normalization&rdquo; (LRN) after 1st and 2nd convolutional layers, which aided generalization, reducing the top-5 error rate by 1.2%. Although this technique has largely fallen out of use, but it was an early precursor to batch normalization.</p>
<p><strong>Pooling layer</strong>: The network includes max-pooling layers with a $3 \times 3$ kernel and a stride of 2, referred to as &ldquo;overlapping pooling&rdquo; due to the overlap of the kernels. The authors observed during training that this approach makes it slightly more difficult for the model to overfit, resulting in 0.3% lower error rate compared to a non-overlapping scheme (kernel size of 2 and stride of 2).</p>
<p><strong>Dropout</strong>: The network&rsquo;s size (60 million parameters) made overfitting a significant problem, even with such a large dataset. To address this, dropout with a probability of $0.5$ was added to the first two fully-connected layers, where the majority of parameters are located. Without dropout, the network required double the number of iterations for convergence.</p>
<figure class="align-center ">
    <img loading="lazy" src="../alexnet-computation.png#center"
         alt="Model summary of AlexNet" width="450"/> <figcaption>
            <p>Model summary of AlexNet</p>
        </figcaption>
</figure>

<h3 id="data-manipulation">Data Manipulation<a hidden class="anchor" aria-hidden="true" href="#data-manipulation">#</a></h3>
<ul>
<li>
<p><strong>Preprocessing</strong>: The mean image of the training set (per-pixel mean) is subtracted from each pixel.</p>
</li>
<li>
<p><strong>Augmentation</strong>: Two data augmentation techniques are used to further reduce overfitting. These augmentations are performed on-the-fly on the CPU, while the GPUs trained the previous batch, making them computationally &ldquo;free&rdquo;.</p>
<ol>
<li>
<p>Image translations and horizontal reflection:</p>
<ul>
<li>
<p>Training: Random $224 \times 224$ patches (and their horizontal reflections) are extracted from $256 \times 256$ images for training.</p>
<ul>
<li>Number of transformations: $(256 - 224) * (256 - 224) = 1024$</li>
<li>Horizontal reflections: $1024 * 2 = 2048$</li>
</ul>
</li>
<li>
<p>Testing: The network makes a prediction by extracting five $224 \times 224$ patches (four corner patches and the center patch) as well as their horizontal reflections, averaging predictions across all ten patches.</p>
</li>
</ul>
</li>
<li>
<p>PCA color augmentation (also called <a href="https://aparico.github.io/">Fancy PCA</a>): This technique alters the intensities of the RGB channels in the training images. It captures an important property of images—that object identity remains invariant to changes in intensity and illumination color.</p>
</li>
</ol>
</li>
</ul>
<h3 id="training">Training<a hidden class="anchor" aria-hidden="true" href="#training">#</a></h3>
<p>Key hyperparameters used for training AlexNet:</p>
<ul>
<li>
<p><strong>Initialization</strong>:</p>
<ul>
<li>Weights: Initialized from a zero-mean Gaussian distribution with a standard deviation of $0.01$ for each layer.</li>
<li>Bias: Initialized to $1$ for the 2nd, 4th, and 5th convolutional layers, as well as in the fully connected layers. This choice accelerates early learning by providing ReLUs with positive inputs. All other layers have their biases initialized to $0$.</li>
</ul>
</li>
<li>
<p><strong>Loss Function</strong>: Cross-entropy loss.</p>
</li>
<li>
<p><strong>Optimizer</strong>: Stochastic gradient descent (SGD)</p>
<ul>
<li>Momentum $m = 0.9$</li>
<li>L2 weight decay $\lambda =  5e^{-4}$</li>
<li>Batch size: 128</li>
</ul>
</li>
<li>
<p><strong>Learning rate</strong>: Initially set to $0.01$ and reduced three times prior to termination by dividing by 10 when the validation error rate stopped improving with the current learning rate.</p>
</li>
<li>
<p><strong>Number of epochs</strong>: 90</p>
</li>
<li>
<p><strong>Training time</strong>: 5 to 6 days on two GTX 580 3GB GPUs.</p>
</li>
</ul>
<figure class="align-center ">
    <img loading="lazy" src="../alexnet-og.png#center"/> 
</figure>

<p>The image above illustrates a typical AlexNet architecture. The model was spread across two GTX 580 3GB GPUs, as it was too large to fit into the memory of a single GPU. The GPUs communicated only in certain layers to optimize computation. However, with modern hardware, this complexity is unnecessary; today, the entire model can be trained on a single GPU (Google Colab, for instance, offers 12GB/16GB GPUs).</p>
<p><strong>Submission</strong>: The CNN architecture described above achieved a top-5 error rate of 18.2%. The authors submitted an ensemble of 5 similar CNNs that yielded an error rate of 16.4%, winning the 2012 challenge.</p>
<h2 id="zfnet-2013">ZFNet (2013)<a hidden class="anchor" aria-hidden="true" href="#zfnet-2013">#</a></h2>
<p>With AlexNet stealing the show in 2012, there was a significant increase in the number of CNN models submitted to ILSVRC 2013. The winner was ZFNet <a href="#references">[2]</a>, an improved version of AlexNet that tweaked some layer configurations to achieve better performance.</p>
<ol>
<li><strong>First layer adjustment</strong>: Alexnet used a large filter size of $11 \times 11$ with a stride of 4 in the first layer. While this aggressive downsampling reduced computational cost, it also resulted in the loss of relevant pixel information. To address this, ZFNet used a $7 \times 7$ sized filter with a stride of 2 in the first layer.</li>
</ol>
<p>To justify these changes, the authors proposed &ldquo;deconvnet&rdquo;, a technique to project output feature maps from each convolutional layer back to the input pixel space. This allows us to visualize different types of features learned by each layer, providing insights into the inner workings of CNNs:</p>
<ul>
<li>
<p><strong>Visualization</strong>: Initial layers learn to detect general patterns such as corners, edges, and textures, while deeper layers capture class-specific details like dog faces, bird legs, and other object parts.</p>
</li>
<li>
<p><strong>Evolution during training</strong>: Lower layers of the model converged within a few epochs, while the upper layers only developed after a considerable number of epochs, demonstrating the need to let the models train until fully converged.</p>
</li>
<li>
<p><strong>Invariance</strong>: Small transformations strongly affect the first layer, while higher layers show greater stability, with minimal impact from translations and scalings. The network output remains stable under these transformations.</p>
</li>
<li>
<p><strong>Occlusion</strong>: When an object is occluded, the probability of the correct class drops significantly, indicating that the model relies heavily on local structure within the image rather than broad scene context.</p>
</li>
</ul>
<ol start="2">
<li><strong>Model size adjustment</strong>: The authors also conducted an ablation study that revealed performance gains from increasing the size of the middle convolutional layers. Consequently, they modified layers 3, 4, and 5 to have 512, 1024, and 512 output channels, respectively.</li>
</ol>
<p>An ensemble of 6 CNNs—five with the modified first layer and one incorporating both modifications—achieved the lowest error rate.</p>
<figure class="align-center ">
    <img loading="lazy" src="../zfnet-accuracy.png#center"
         alt="ImageNet 2012 classification error rates" width="600"/> <figcaption>
            <p>ImageNet 2012 classification error rates</p>
        </figcaption>
</figure>

<p>AlexNet and ZFNet were designed in a somewhat ad-hoc manner, with an arbitrary number of convolution and pooling layers, and the configurations of each layer set by trial and error. This makes scaling them quite challenging.</p>
<h2 id="vggnet-2014">VGGNet (2014)<a hidden class="anchor" aria-hidden="true" href="#vggnet-2014">#</a></h2>
<p>In 2014, the second-place winner of the ImageNet challenge was VGGNet <a href="#references">[3]</a>, developed by the Visual Geometry Group at Oxford. This architecture was one of the first to have a principled design that guided the overall configuration of the network, enabling the creation of deeper networks and achieving significant improvements over previous configurations.</p>
<h3 id="architecture-1">Architecture<a hidden class="anchor" aria-hidden="true" href="#architecture-1">#</a></h3>
<p>Let&rsquo;s take a look at a side-by-side comparison of AlexNet, ZFNet, VGG-16, and VGG-19 architectures.</p>
<figure class="align-center ">
    <img loading="lazy" src="../comparison.png#center" width="700"/> 
</figure>

<p>VGGNet features clean and simple design principles. The configuration for each stage is fixed as follows:</p>
<ul>
<li>
<p><strong>Convolutional layers</strong>: Kernel size of $3 \times 3$, with a stride of 1 and padding of 1 (same padding).</p>
<ul>
<li>Why? This is the smallest kernel capable of capturing directionality (left/right, up/down, center). This design choice ensures that the network remains compact while allowing for greater depth.</li>
</ul>
</li>
<li>
<p><strong>Max-pooling layers</strong>: Kernel size of $2 \times 2$, with a stride of 2.</p>
</li>
<li>
<p><strong>Channels</strong>: Starting from 64, the number of channels doubles after each pooling layer, reaching a maximum of 512.</p>
<ul>
<li>When the pooling layer downsamples the feature map by half, we double the number of channels to preserve the overall volume, thereby maintaining consistent time complexity (FLOPs) across each layer.</li>
</ul>
</li>
<li>
<p><strong>Activation</strong>: ReLU non-linearities are used thoughout the network.</p>
</li>
<li>
<p><strong>Normalization</strong>: No normalization is applied, as it does not improve performance and instead increases memory consumption and computation time.</p>
</li>
<li>
<p><strong>Dropout</strong>: Added to the first two fully connected layers, with a dropout ratio of $0.5$.</p>
</li>
</ul>
<p>While AlexNet has 5 convolutional layers, VGGNet comprises 5 stages:</p>
<p>Stage 1: conv-conv-pool<br>
Stage 2: conv-conv-pool<br>
Stage 3: conv-conv-conv-[conv]-pool<br>
Stage 4: conv-conv-conv-[conv]-pool<br>
Stage 5: conv-conv-conv-[conv]-pool</p>
<p>Two VGGNet variants were presented: VGG-16 and VGG-19, with 16 and 19 layers, respectively. VGG-19 includes an additional convolutional layer in stages 3, 4, and 5.</p>
<p>The convolutional layers are stacked to increase the receptive field. For instance, a stack of two $3 \times 3$ layers achieves an effective receptive field of $5 \times 5$, and three layers result in $7 \times 7$. What do we gain by using three $3 \times 3$ layers instead of a single $7 \times 7$ layer?</p>
<ol>
<li>
<p>More activations:Three non-linearities instead of one, making the decision function more discriminative.</p>
</li>
<li>
<p>Fewer parameters: Assuming the input and output have $C$ channels:</p>
<ul>
<li>Three $3 \times 3$ layers: $3(3 * 3 * C^2) = 27C^2$ params.</li>
<li>A single $7 \times 7$ layer: $7 * 7 * C^2 = 49C^2$ params.</li>
</ul>
</li>
</ol>
<figure class="align-center ">
    <img loading="lazy" src="../vggnet.png#center" width="550"/> 
</figure>

<h3 id="data-manipulation-1">Data Manipulation<a hidden class="anchor" aria-hidden="true" href="#data-manipulation-1">#</a></h3>
<ul>
<li>
<p><strong>Preprocessing</strong>: The mean RGB value from the training set (per-channel mean) is subtracted from each pixel.</p>
</li>
<li>
<p><strong>Augmentation</strong>: Training images are first rescaled to a training scale, $S$. These rescaled images are then randomly cropped to $224 \times 224$ and undergo random horizontal flipping and random RGB color shifting (similar to AlexNet).</p>
<ol>
<li>
<p>Single training scale:</p>
<ul>
<li>Training: Models are trained at two fixed scales, $S = 256$ or $S = 384$.</li>
<li>Testing: The output is averaged over three test image versions rescaled at $ \{ S - 32, S, S + 32 \} $.</li>
</ul>
</li>
<li>
<p>Multi-training scale:</p>
<ul>
<li>Training: Each image is rescaled individually by randomly sampling $S$ from the range $[S_{min} =256, S_{max} = 512]$. This approach, called scale jittering, enables the model to recognize objects at different scales.</li>
<li>Testing: The output is averaged over three test image versions rescaled at $ \{ S_{min}, S_{avg}, S_{max} \}  = \{256, 384, 512 \} $.</li>
</ul>
</li>
</ol>
<p>This provides three trained versions of the same network: two single-scale models trained at fixed scales and one model trained using multiple scales.</p>
</li>
</ul>
<h3 id="training-1">Training<a hidden class="anchor" aria-hidden="true" href="#training-1">#</a></h3>
<p>Training hyperparameters and choices are similar to AlexNet.</p>
<ul>
<li>
<p><strong>Initialization</strong>:</p>
<ul>
<li>Pre-training: A shallow network is first trained with random initialization (weights from a zero-mean Gaussian distribution with $0.01$ variance and biases set to $0$), and then re-trained with additional convolutional layers.</li>
<li>Xavier initialization: After submission, the authors discovered that Xavier initialization enables training without the need for pre-training.</li>
</ul>
</li>
<li>
<p><strong>Loss Function</strong>: Cross-entropy loss.</p>
</li>
<li>
<p><strong>Optimizer</strong>: Stochastic gradient descent (SGD)</p>
<ul>
<li>Momentum $m = 0.9$</li>
<li>L2 weight decay $\lambda =  5e^{-4}$</li>
<li>Batch size: 256</li>
</ul>
</li>
<li>
<p><strong>Learning rate</strong>: Initialized at $0.01$, and reduced three times by dividing by 10 when the validation accuracy stopped improving.</p>
</li>
<li>
<p><strong>Number of epochs</strong>: 74</p>
</li>
<li>
<p><strong>Training time</strong>: 2-3 weeks on four Titan Black 6GB GPUs.</p>
</li>
</ul>
<p>Despite having more parameters and greater depth than AlexNet, VGGNet required fewer epochs to converge due to (a) implicit regularization imposed by greater depth and and smaller convolutional filter sizes, and (b) pre-initialization of certain layers.</p>
<p><strong>Submission</strong>: The authors submitted an ensemble of 7 networks—six single-scale models and one multi-scale model—resulting in a top-5 error rate of 7.3%.</p>
<figure class="align-center ">
    <img loading="lazy" src="../vgg-submission.png#center" width="600"/> 
</figure>

<h2 id="resnet-2015">ResNet (2015)<a hidden class="anchor" aria-hidden="true" href="#resnet-2015">#</a></h2>
<p>By 2015, it had become clear that increasing a network’s depth significantly improved its performance. However, deep networks typically face two major challenges:</p>
<ol>
<li>
<p>Overfitting: Regularization techniques like Batch Normalization (BatchNorm) help mitigate overfitting and enable higher learning rates.</p>
</li>
<li>
<p>Vanishing/Exploding gradients: Non-saturating activations like ReLU, combined with Kaiming Initialization to preserve signal variance, help address this. BatchNorm further ensures that forward-propagated signals maintain stable, non-zero variances.</p>
</li>
</ol>
<p>WThe development of BatchNorm and Kaiming Initialization in 2015 set the stage for experimenting with deeper models. However, a “degradation problem” came into light: as network depth increased, accuracy would initially saturate (which might be expected) and then degrade rapidly.</p>
<figure class="align-center ">
    <img loading="lazy" src="../resnet-problem.png#center"
         alt="Training error (left) and test error (right) on CIFAR-10 with 20-layer and 56-layer networks. The deeper network has higher training and test error."/> <figcaption>
            <p>Training error (left) and test error (right) on CIFAR-10 with 20-layer and 56-layer networks. The deeper network has higher training and test error.</p>
        </figcaption>
</figure>

<p>This degradation is not caused by overfitting, as deeper networks exhibit higher training error than their shallower counterparts, as shown in the figure above. The hypothesis suggests that this may be an optimization problem, indicating that deeper models are challenging to optimize, leading to <em>underfiting</em>.</p>
<h3 id="architecture-2">Architecture<a hidden class="anchor" aria-hidden="true" href="#architecture-2">#</a></h3>
<p>Intuitively, we expect a deeper model to perform at least as well as a shallower model since it could theoretically emulate the shallower network by copying its layers and and setting the extra layers to identity.
The fact that deeper models performed worse suggests that the solvers struggle to approximate identity mappings with multiple non-linear layers.</p>
<h4 id="residual-block">Residual Block<a hidden class="anchor" aria-hidden="true" href="#residual-block">#</a></h4>
<p>To address this, ResNet <a href="#references">[4]</a> introduced a new network design that simplifies learning identity mappings. If we let the stacked non-linear layers fit a mapping $\text{F(x)}$ for an input $\text{x}$, we can add a skip connection to recasted the original mapping to $\text{F(x) + x}$.</p>
<figure class="align-center ">
    <img loading="lazy" src="../residual.png#center" width="600"/> 
</figure>

<p>To the extreme, if an indentity mapping was optimal, the solver would push the residual to zero, i.e. drive the weights of non-linear layers toward zero to approximate the identity mapping.</p>
<p>While it is unlikely that identity mappings are optimal in practice, this reformulation helps precondition the problem, making it easier for the solver to find perturbations relative to an identity mapping rather than learning a new function from scratch.</p>
<p>These shortcut connections neither add extra parameters nor increase computational complexity, and they can be trained end-to-end using SGD with backpropagation without modification.</p>
<p>A residual network, or ResNet, is formed by stacking multiple residual blocks. The image below shows a comparison of VGG-19, 34-layer plain, and residual networks.</p>
<figure class="align-center ">
    <img loading="lazy" src="../resnet.png#center" width="600"/> 
</figure>

<p>Similar to VGGNet, ResNet is divided into four stages, each with a different number of residual blocks. The architecture includes:</p>
<ul>
<li>
<p><strong>Aggresive Stem</strong>: The input is aggressively downsampled with a $7 \times 7$ filter and stride 2 (similar to ZFNet) before applying residual blocks.</p>
</li>
<li>
<p><strong>Residual block</strong>: Each residual block contains two $3 \times 3$ convolutional layers.</p>
<ul>
<li>
<p>Element-wise addition is performed on two feature maps, channel by channel.</p>
</li>
<li>
<p>Skip connection across two stages (shown by dotted lines): A $1 \times 1$ convolution is added to the input to match the channel dimension, using a stride of 2 to match the spatial dimension. The output is given by,
$$
\text{H(x) = F(x) + W x}
$$
where $\text{W}$ is the projection shortcut, used solely for changing dimensions; other shortcuts are identity.</p>
</li>
</ul>
</li>
<li>
<p><strong>Channels</strong>: Starting with 64 channels, the number is doubled after each stage, up to 512.</p>
</li>
<li>
<p><strong>Strided convolution</strong>: Instead of using pooling layers to halve the feature map after each stage, a stride of 2 is used in the first convolution of the next stage.</p>
</li>
<li>
<p><strong>Normalization</strong>: Each convolution is followed by a BatchNorm layer and a ReLU activation function.</p>
</li>
<li>
<p><strong>Global average pooling</strong>:  Instead of using fully connected layers, the network ends with a global average pooling layer followed by a single linear layer with softmax to generate class scores.</p>
<ul>
<li>Why? Fully connected layers have large number of parameters, increasing memory usage.</li>
<li>Average pooling is applied to the last convolutional layer ($512 \times 7 \times 7$) using a $7 \times 7$ kernel to cover the entire spatial structure.</li>
</ul>
</li>
</ul>
<p>The authors presented two variants, ResNet-18 and ResNet-34, which have lower complexity than VGG-19, which has 19.6 GFLOPs.</p>
<figure class="align-center ">
    <img loading="lazy" src="../resnet-18-34.png#center" width="700"/> 
</figure>

<p>As the 34-layer network performed better than the 18-layer network, it was clear that adding more layers could yield better performance. However, this also increases computational costs.</p>
<h4 id="bottleneck-residual-block">Bottleneck Residual Block<a hidden class="anchor" aria-hidden="true" href="#bottleneck-residual-block">#</a></h4>
<p>To reduce computation, a bottleneck block is introduced with three convolutions: $1 \times 1$, $3 \times 3$ and $1 \times 1$. The pointwise convolutions are used to reduce and then restore dimensions.</p>
<figure class="align-center ">
    <img loading="lazy" src="../bottleneck.png#center" width="600"/> 
</figure>

<p>Comparing FLOPs = $(C_{out} \times H&rsquo; \times W&rsquo;)* (C_{in} \times K_w \times K_h)$,</p>
<ul>
<li>
<p>Basic residual block: $2 * [(64 \times 56 \times 56) * (64 \times 3 \times 3)]$ = $0.24$ GFLOPs.</p>
</li>
<li>
<p>Bottleneck residual block: $2 * [(64 \times 56 \times 56) * (256 \times 1 \times 1)]$ + $[(64 \times 56 \times 56) * (64 \times 3 \times 3)]$ = $0.22$ GFLOPs.</p>
</li>
</ul>
<p>These additions introduce extra layers and non-linearities with a slight reduction in computational cost, enabling ResNet to add more layers without significantly increasing overall complexity.</p>
<p>Replacing all basic blocks in ResNet-34 with bottleneck blocks results in the ResNet-50 architecture, a widely-used baseline. The authors further expanded ResNet with 101 and 152-layer variants using different numbers of bottleneck blocks.</p>
<figure class="align-center ">
    <img loading="lazy" src="../resnet-all-variant.png#center"
         alt="Architecture of ResNet variants. Downsampling is performed by the first convolution of stages 2, 3, and 4 with a stride of 2. Error rates shown are for single-crop testing, as reported by torchvision."/> <figcaption>
            <p>Architecture of ResNet variants. Downsampling is performed by the first convolution of stages 2, 3, and 4 with a stride of 2. Error rates shown are for single-crop testing, as reported by <a href="https://pytorch.org/hub/pytorch_vision_resnet/">torchvision</a>.</p>
        </figcaption>
</figure>

<h3 id="data-manipulation-2">Data Manipulation<a hidden class="anchor" aria-hidden="true" href="#data-manipulation-2">#</a></h3>
<ul>
<li>
<p><strong>Preprocessing</strong>: A per-pixel mean is subtracted, as in AlexNet.</p>
</li>
<li>
<p><strong>Augmentation</strong>: Similar to VGGNet, multi-scale training is applied.</p>
<ul>
<li>
<p>Training: Images are randomly rescaled in range $[256, 480]$ for scale augmentation, then randomly cropped to $224 \times 224$, and subjected to random horizontal flipping and random RGB color shifting.</p>
</li>
<li>
<p>Testing: Scores are averaged across multiple scales: $\{ 224, 256, 384, 480, 640 \}$.</p>
</li>
</ul>
</li>
</ul>
<h3 id="training-2">Training<a hidden class="anchor" aria-hidden="true" href="#training-2">#</a></h3>
<p>Ttraining hyperparameters and choices are as follows.</p>
<ul>
<li>
<p><strong>Initialization</strong>: Kaiming Initialization</p>
</li>
<li>
<p><strong>Loss Function</strong>: Cross-entropy loss.</p>
</li>
<li>
<p><strong>Optimizer</strong>: Stochastic gradient descent (SGD)</p>
<ul>
<li>Momentum $m = 0.9$</li>
<li>L2 weight decay $\lambda =  1e^{-4}$</li>
<li>Batch size: 256</li>
</ul>
</li>
<li>
<p><strong>Learning rate</strong>: Initialized at $0.1$ and divided by 10 when the error plateus.</p>
</li>
<li>
<p><strong>Number of epochs</strong>: 120 ($60 \times 10^{4}$ iterations)</p>
</li>
</ul>
<p><strong>Submission</strong>: The authors submitted an ensemble of six networks with varying depths, achieving a 3.57% error rate—surpassing human performance and securing the 2015 ImageNet challenge win.</p>
<h2 id="transfer-learning">Transfer Learning<a hidden class="anchor" aria-hidden="true" href="#transfer-learning">#</a></h2>
<p>Beyond using these CNN models solely for inspiration, transfer learning enables us to apply them directly to many tasks—even with limited training data!</p>
<p>The core idea is to take a model pre-trained on ImageNet, remove its last fully-connected layer, and freeze the weights of the remaining layers. With this setup, the pre-trained model becomes an excellent feature extractor, effectively capturing complex patterns from input images.</p>
<ul>
<li>
<p>Smaller dataset: For smaller datasets, we typically train a new linear layer on top of this feature extractor, tailored to our specific task. This approach has proven effective across various downstream tasks, delivering impressive performance even with minimal data.</p>
</li>
<li>
<p>Larger dataset: For larger datasets, you can go further with <strong>fine-tuning</strong>. Here, we combine the new linear layer with the pre-trained network and jointly train them on the new data. This gradual adjustment allows the network to adapt to the nuances of the new dataset while retaining valuable prior knowledge.</p>
</li>
</ul>
<figure class="align-center ">
    <img loading="lazy" src="../transfer-learning.png#center"/> 
</figure>

<p> </p>
<h2 id="references">References<a hidden class="anchor" aria-hidden="true" href="#references">#</a></h2>
<p>[1] Alex Krizhevsky, Ilya Sutskever, and Geoffrey Hinton, &ldquo;<a href="https://proceedings.neurips.cc/paper_files/paper/2012/file/c399862d3b9d6b76c8436e924a68c45b-Paper.pdf">ImageNet Classification with Deep Convolutional Neural Networks</a>&rdquo;, NeurIPS 2012.</p>
<p>[2] Matthew D. Zeiler and Rob Fergus. “<a href="https://arxiv.org/abs/1311.2901">Visualizing and Understanding Convolutional Networks</a>”, ECCV 2014.</p>
<p>[3] Simonyan and Zissermann, “<a href="https://arxiv.org/abs/1409.1556">Very Deep Convolutional Networks for Large-Scale Image Recognition</a>”, ICLR 2015.</p>
<p>[4] He et al, “<a href="https://arxiv.org/abs/1512.03385">Deep Residual Learning for Image Recognition</a>”, CVPR 2016.</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
<nav class="paginav">
  <a class="prev" href="https://yugajmera.github.io/posts/06-attention/post/">
    <span class="title">« Prev</span>
    <br>
    <span>Sequence Modeling with Recurrent Neural Networks and Attention</span>
  </a>
  <a class="next" href="https://yugajmera.github.io/posts/04-cnn/post/">
    <span class="title">Next »</span>
    <br>
    <span>Convolutional Neural Networks: Deep Learning for Image Recognition</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2024 <a href="https://yugajmera.github.io/">YA&#39;s Almanac</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
